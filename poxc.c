/** poxc.c
 * 
 **
 * This file is part of PoshX project.
 * Under GPLv3. See COPYING for more details.
 * Obey the KING Principle.
 * NO WARRANTY!
 **
 * AUTHORS:
 *		eXerigumo Clanjor
 * COPYLEFT(C):
 *		Clan Open Studio, 2010-2011.
 */

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "poxc.h"
#include "error.h"
#include "symtab.h"
#include "common.h"

void poxc_compile_file(STRING filein, STRING fileout)
{
	// TODO Optimize this so that when unexpectedly exit...
	//		You know it.
	FILE * fpin = fopen(filein, "r");
	FILE * fpout = fopen(fileout, "wb");

	if (fpin == NULL || fpout == NULL){
		if (fpin != NULL) fclose(fpin);
		if (fpout != NULL) fclose(fpout);
		throw(ERR_FILEOP_FAILED);
	}

	poxc_compile(fpin, fpout);

	fclose(fpin);
	fclose(fpout);
}

static int tk_type = TYPE_UNKNOWN;
static char *tk_text = NULL;
static int tk_value = -1;
static bool lex_finished = false;
static u16 current_code = 0;
static struct _code
{
	byte code;
	u16 addr;
	int addr_type;
} codes[0xFFFF];

void poxc_compile(FILE * fpin, FILE * fpout)
{
	poxc_parse(fpin);
	poxc_write(fpout);
}

/**
 * Read text from fp and generate grammer tree
 **
 * @param	fp: File pointer to the input file stream
 */
inline void poxc_parse(FILE * fp)
{
	poxc_lex(fp);
	for (;;){
		if (lex_finished) break;

#ifdef __DEBUG__
		if (tk_type == TYPE_KEY)
			debug("LEX[%d]\t%s", tk_type, tk_text);
		else if (tk_type == TYPE_LABEL)
			debug("LEX[%d]\t(LABEL)*%d", tk_type, tk_value);
		else if (tk_type == TYPE_VALUE)
			debug("LEX[%d]\t(VALUE)*%d", tk_type, tk_value);
		else
			debug("LEX[%d]\t(VAR)*%d", tk_type, tk_value);
#endif

		// Instruction
		if (tk_type == TYPE_KEY){
			// Save old STRING
			char * tt = tk_text;

			// Get parameter
			poxc_lex(fp);

			if (strcmp(tt, "label") == 0) {
				// Label definition...
				if (tk_type == TYPE_LABEL){
					symtab_set_label(tk_value, current_code);
					poxc_lex(fp);
				}
				else throw(ERR_UNEXPECTED_V);
			}
			else {
				// ...or normal code
				emit_code(tt);
				if (tk_type != TYPE_KEY) poxc_lex(fp);
			}
			free(tt);
		}

		// Unknow?
		else throw(ERR_UNEXPECTED_V);
	}
}

void poxc_lex(FILE * fp)
{
	// Clean up first
	tk_type = TYPE_UNKNOWN;
	tk_value = -1;

	int pos = 0; // Cursor of current char in tk_text
	tk_text = malloc(MAX_NAME_LEN);
	if (tk_text == NULL) throw(ERR_MEMOP_FAILED);

	char ch;
	while (!feof(fp)){
		ch = getc(fp);

		// Skip blank
		// The '\r' is for Mac, not for Windows!!!
		// Fuck Windows, fuck Bill!
		if (ch != ' ' && ch != '\t' && ch != '\n' 
				&& ch != '\r' && ch != '#')
			break;

		// Skip comment
		if (ch == '#')
			while ((ch = getc(fp)) != '\n')
				if (feof(fp)) break;
	}

	if (feof(fp)){
		lex_finished = true;
		return;
	}

	// Identifier or label
	if (ch == ':' || ch == '.' || ch == '_' || isalpha(ch)){
		tk_type = TYPE_IDENT;
		tk_text[pos++] = ch;
		while (isalnum(ch = getc(fp)) || ch == '.' || ch == '_'){
			if (feof(fp)) break;
			if (pos == MAX_NAME_LEN) throw(ERR_ID_TOO_LONG);
			tk_text[pos++] = ch;
		}
		tk_text[pos] = 0; // A STRING ends with 0

		// Is label?
		if (tk_text[0] == ':'){
			tk_type = TYPE_LABEL;
			tk_value = symtab_append_label(tk_text);
			free(tk_text);
			tk_text = NULL;
		}

		// Is keyword?
		else if (is_key(tk_text)) tk_type = TYPE_KEY;

		// Oh, that's a variable
		else {
			tk_value = symtab_append_var(tk_text);
			free(tk_text);
			tk_text = NULL;
		}
	}

	// Value
	else if (isdigit(ch)){
		tk_type = TYPE_VALUE;
		tk_text[pos++] = ch;
		while (isdigit(ch = getc(fp))){
			if (feof(fp)) break;
			if (pos == MAX_NAME_LEN) throw(ERR_ID_TOO_LONG);
			tk_text[pos++] = ch;
		}
		tk_text[pos] = 0;
		tk_value = symtab_append_value(tk_text);
		free(tk_text);
		tk_text = NULL;
	}

	// Unknown
	else {
		debug("%c", ch);
		throw(ERR_UNKNOWN_CH);
	}
}

static STRING keywords[] = {
	"nop", "push", "pop", "popa", "jmp", "jz", "call", "cz", "ret",
	"inc", "dec", "add", "sub", "mul", "div", "mod", "gt", "lt", "eq",
	"and", "or", "not", "in", "out", "halt", "label", NULL
};

inline bool is_key(STRING id_to_check)
{
	int i;
	for(i=0; keywords[i]!=NULL; i++)
		if (strcmp(id_to_check, keywords[i]) == 0)
			return true;
	return false;
}

void emit_code(STRING key)
{
	debug("[EMIT] %s(*%d:%d);", key, tk_value, 
			(tk_type==TYPE_KEY ? TYPE_UNKNOWN : tk_type));

	// Overflow?
	if (current_code == 0xFFFF) throw(ERR_CODETAB_OVERFLOW);

	// Save data
	if (tk_type == TYPE_KEY){
		codes[current_code].addr_type = TYPE_UNKNOWN;
		codes[current_code].addr = -1;
	}
	else {
		codes[current_code].addr_type = tk_type;
		codes[current_code].addr = tk_value;
	}

	// Generated by awk
	if (strcmp(key, "nop") == 0)
		codes[current_code].code = NOP;
	else if (strcmp(key, "push") == 0)
		codes[current_code].code = PUSH;
	else if (strcmp(key, "pop") == 0)
		codes[current_code].code = POP;
	else if (strcmp(key, "popa") == 0)
		codes[current_code].code = POPA;
	else if (strcmp(key, "jmp") == 0)
		codes[current_code].code = JMP;
	else if (strcmp(key, "jz") == 0)
		codes[current_code].code = JZ;
	else if (strcmp(key, "call") == 0)
		codes[current_code].code = CALL;
	else if (strcmp(key, "cz") == 0)
		codes[current_code].code = CZ;
	else if (strcmp(key, "ret") == 0)
		codes[current_code].code = RET;
	else if (strcmp(key, "inc") == 0)
		codes[current_code].code = INC;
	else if (strcmp(key, "dec") == 0)
		codes[current_code].code = DEC;
	else if (strcmp(key, "add") == 0)
		codes[current_code].code = ADD;
	else if (strcmp(key, "sub") == 0)
		codes[current_code].code = SUB;
	else if (strcmp(key, "mul") == 0)
		codes[current_code].code = MUL;
	else if (strcmp(key, "div") == 0)
		codes[current_code].code = DIV;
	else if (strcmp(key, "mod") == 0)
		codes[current_code].code = MOD;
	else if (strcmp(key, "gt") == 0)
		codes[current_code].code = GT;
	else if (strcmp(key, "lt") == 0)
		codes[current_code].code = LT;
	else if (strcmp(key, "eq") == 0)
		codes[current_code].code = EQ;
	else if (strcmp(key, "and") == 0)
		codes[current_code].code = AND;
	else if (strcmp(key, "or") == 0)
		codes[current_code].code = OR;
	else if (strcmp(key, "not") == 0)
		codes[current_code].code = NOT;
	else if (strcmp(key, "in") == 0)
		codes[current_code].code = IN;
	else if (strcmp(key, "out") == 0)
		codes[current_code].code = OUT;
	else if (strcmp(key, "halt") == 0)
		codes[current_code].code = HALT;
	else debug("What's fuck? %s", key);

	current_code++;
}

void poxc_write(FILE * fp)
{
	u16 var_len = symtab_get_var_len();

	// POX HEADER (MAGIC LINE & HEADER)
	fprintf(fp, "#!%s\n", POX_MAGIC_LINE);
	fwrite("POX", 1, 3, fp);
	byte pox_ver = POX_VERSION;
	fwrite(&pox_ver, 1, 1, fp);

	u32 sec_len = 0;
	int i;

	// .code section
	// SECTION HEADER
	fwrite(".code", 1, 6, fp);
	sec_len = sizeof(u16) + current_code * sizeof(POX_CODE);
	fwrite(&sec_len, sizeof(u32), 1, fp);

	// CODE DATA
	fwrite(&current_code, sizeof(u16), 1, fp);
	for (i=0; i<current_code; i++){
		fwrite(&codes[i].code, 1, 1, fp);
		u16 addr = codes[i].addr + 0x10; // First 0x10 for registers
		if (codes[i].addr_type == TYPE_VALUE)
			addr += var_len;
		else if (codes[i].addr_type == TYPE_UNKNOWN)
			addr = 0;
		else if (codes[i].addr_type == TYPE_LABEL)
			addr = symtab_get_label(addr-0x10);
		fwrite(&addr, sizeof(u16), 1, fp);
	}

	// .data section
	u16 value_len = symtab_get_value_len();

	// SECTION HEADER
	fwrite(".data", 1, 6, fp);
	// u16     u16        POX_DATA...
	// VAR_LEN   VALUE_LEN    value data...
	sec_len = sizeof(u16) * 2 + value_len * sizeof(POX_DATA);
	fwrite(&sec_len, sizeof(u32), 1, fp);

	// VALUE/VAR DATA
	fwrite(&var_len, sizeof(u16), 1, fp);
	fwrite(&value_len, sizeof(u16), 1, fp);
	for (i=0; i<value_len; i++){
		s32 value = symtab_get_value(i);
		fwrite(&value, sizeof(s32), 1, fp);
	}
}

